{"version":3,"sources":["utils.js","Header.js","NewTransfer.js","TransferList.js","utils/Bus.js","flash/index.js","App.js","index.js"],"names":["getWallet","web3","a","eth","net","getId","networkId","contractDeployment","Wallet","networks","Contract","abi","address","Header","approvers","quorum","join","NewTransfer","createTransfer","useState","undefined","transfer","setTransfer","updateTransfer","e","field","value","target","onSubmit","preventDefault","submit","htmlFor","id","type","onChange","TransferList","transfers","approveTransfer","approvals","map","button","window","ethereum","selectedAddress","disabled","onClick","amount","to","sent","EventEmitter","Flash","visibility","setVisibility","message","setMessage","setType","useEffect","Bus","addListener","setTimeout","document","querySelector","addEventListener","className","App","setWeb3","accounts","setAccounts","wallet","setWallet","setApprovers","setQuorum","setTransfers","setApprovals","Promise","resolve","reject","Web3","enable","getAccounts","methods","getApprovers","call","getTransfers","determineApprovals","init","transferList","_wallet","transferonies","tempWallet","approvalObj","i","length","transferId","send","from","then","catch","err","flash","emit","ReactDOM","render","StrictMode","getElementById"],"mappings":"qtvQAmEMA,G,OAAS,uCAAG,WAAMC,GAAN,iBAAAC,EAAA,sEAEUD,EAAKE,IAAIC,IAAIC,QAFvB,cAERC,EAFQ,OAKRC,EAAqBC,EAAOC,SAASH,GAL7B,kBAOP,IAAIL,EAAKE,IAAIO,SAGhBF,EAAOG,IAEPJ,GAAsBA,EAAmBK,UAZ/B,2CAAH,uD,OCrDAC,MAZf,YAAsC,IAArBC,EAAoB,EAApBA,UAAWC,EAAS,EAATA,OACxB,OACI,iCACI,+BACI,8CAAiBD,EAAUE,KAAK,SAChC,2CAAcD,W,SCkCfE,MApCf,YAAwC,IAAlBC,EAAiB,EAAjBA,eAClB,EAAgCC,wBAASC,GAAzC,mBAAOC,EAAP,KAAiBC,EAAjB,KAOMC,EAAiB,SAACC,EAAGC,GACvB,IAAMC,EAAQF,EAAEG,OAAOD,MAEvBJ,EAAY,2BAAID,GAAL,kBAAgBI,EAAQC,MAGvC,OACI,gCACI,iDACA,uBAAME,SAAU,SAACJ,GAAD,OAdT,SAAAA,GACXA,EAAEK,iBACFX,EAAeG,GAYYS,CAAON,IAA9B,UACI,uBAAOO,QAAQ,SAAf,oBACA,uBACIC,GAAG,SACHC,KAAK,OACLC,SAAU,SAAAV,GAAC,OAAID,EAAeC,EAAG,aAErC,uBAAOO,QAAQ,KAAf,gBACA,uBACIC,GAAG,KACHC,KAAK,OACLC,SAAU,SAAAV,GAAC,OAAID,EAAeC,EAAG,SAErC,mDCeDW,MA/Cf,YAAgE,IAAzCC,EAAwC,EAAxCA,UAAWC,EAA6B,EAA7BA,gBAAiBC,EAAY,EAAZA,UAC/C,OACI,gCACI,2CACA,kCACI,gCACI,+BACI,oCACA,wCACA,yCACA,2CACA,2CAGR,gCACKF,EAAUG,KAAI,SAAAlB,GACX,IAAImB,EAWJ,OARQA,EAFLF,EAAUG,OAAOC,SAASC,kBACtBL,EAAUG,OAAOC,SAASC,iBAAiBtB,EAASW,IAC1C,wBAAQY,UAAQ,EAAhB,qBAKJ,wBAAQC,QAAS,kBAAMR,EAAgBhB,EAASW,KAAhD,qBAIT,+BACI,6BAAKX,EAASW,KACd,6BAAKX,EAASyB,SACd,6BAAKzB,EAAS0B,KACd,+BACK1B,EAASiB,UACRE,KAEN,6BAAKnB,EAAS2B,KAAO,MAAQ,SARxB3B,EAASW,gB,QC7B/B,M,OAAIiB,GCGNC,G,OAAQ,WACjB,MAAkC/B,oBAAS,GAA3C,mBAAKgC,EAAL,KAAiBC,EAAjB,KACA,EAA4BjC,mBAAS,IAArC,mBAAKkC,EAAL,KAAcC,EAAd,KACA,EAAsBnC,mBAAS,IAA/B,mBAAKc,EAAL,KAAWsB,EAAX,KAuBA,OArBAC,qBAAU,WACNC,EAAIC,YAAY,SAAS,YAAsB,IAApBL,EAAmB,EAAnBA,QAASpB,EAAU,EAAVA,KAChCmB,GAAc,GACdE,EAAWD,GACXE,EAAQtB,GACR0B,YAAW,WACPP,GAAc,KACf,UAIR,IAEHI,qBAAU,WACkC,OAArCI,SAASC,cAAc,WACtBD,SACCC,cAAc,UACdC,iBAAiB,SAAS,kBAAMV,GAAc,SAKnDD,GAAc,sBAAKY,UAAS,sBAAiB9B,GAA/B,UACN,sBAAM8B,UAAU,QAAhB,SAAwB,yCACxB,4BAAIV,SCqHLW,MA7If,WAEE,MAAwB7C,wBAASC,GAAjC,mBAAOnB,EAAP,KAAagE,EAAb,KACA,EAAgC9C,wBAASC,GAAzC,mBAAO8C,EAAP,KAAiBC,EAAjB,KACA,EAA4BhD,wBAASC,GAArC,mBAAOgD,EAAP,KAAeC,EAAf,KACA,EAAkClD,mBAAS,IAA3C,mBAAOL,EAAP,KAAkBwD,EAAlB,KACA,EAA4BnD,wBAASC,GAArC,mBAAOL,EAAP,KAAewD,EAAf,KACA,EAAkCpD,mBAAS,IAA3C,mBAAOiB,EAAP,KAAkBoC,EAAlB,KACA,EAAkCrD,mBAAS,IAA3C,mBAAOmB,EAAP,KAAkBmC,EAAlB,KAGAjB,qBAAU,YACE,uCAAG,sCAAAtD,EAAA,sENPN,IAAIwE,SAAQ,SAACC,EAASC,GAEzBnC,OAAOqB,iBAAiB,OAAxB,sBAAgC,4BAAA5D,EAAA,0DAGzBuC,OAAOC,SAHkB,wBAKlBzC,EAAO,IAAI4E,IAAKpC,OAAOC,UALL,kBAQdD,OAAOC,SAASoC,SARF,OASpBH,EAAQ1E,GATY,gDAYpB2E,EAAO,EAAD,IAZc,gCAelBnC,OAAOxC,KACb0E,EAAQlC,OAAOxC,MAGf2E,EAAO,qCAnBiB,6DMKvB,cAEL3E,EAFK,gBAIYA,EAAKE,IAAI4E,cAJrB,cAILb,EAJK,gBAMUlE,EAAUC,GANpB,cAMLmE,EANK,iBAOaA,EAAOY,QAAQC,eAAeC,OAP3C,eAOLpE,EAPK,iBAQUsD,EAAOY,QAAQjE,SAASmE,OARlC,eAQLnE,EARK,iBASaqD,EAAOY,QAAQG,eAAeD,OAT3C,eASL9C,EATK,OAYX6B,EAAQhE,GACRkE,EAAYD,GACZG,EAAUD,GACVE,EAAaxD,GACbyD,EAAUxD,GACVyD,EAAapC,GAjBF,KAwBXqC,EAxBW,UAwBQW,EAAmBhD,EAAWgC,GAxBtC,+EAAH,qDA2BViB,MAKF,IAAMD,EAAkB,uCAAG,WAAOE,EAAcC,GAArB,qBAAArF,EAAA,sDAKvBsF,EADCF,GAGelD,EAIhBqD,EADCF,GAGYnB,EAGXsB,EAhBqB,eAiBtBjD,OAAOC,SAASC,gBAAkB,IAE7BgD,EAAE,EAnBe,YAmBZA,EAAIH,EAAcI,QAnBN,iCAoBdH,EAAWT,QAAQ1C,UAAUG,OAAOC,SAASC,gBAAiB6C,EAAcG,GAAG3D,IAAIkD,OApBrE,mCAqBrBQ,EAAYjD,OAAOC,SAASC,iBAAiB6C,EAAcG,GAAG3D,KAAM,EArB/C,wBAuBrB0D,EAAYjD,OAAOC,SAASC,iBAAiB6C,EAAcG,GAAG3D,KAAM,EAvB/C,QAmBc2D,IAnBd,2BA0BtBL,EA1BsB,0CA2BhBI,GA3BgB,QA6BvBjB,EAAaiB,GA7BU,4CAAH,wDAmDlBrD,EAAe,uCAAG,WAAMwD,GAAN,SAAA3F,EAAA,sDACtBkE,EAAOY,QACJ3C,gBAAgBwD,GAEhBC,KAAK,CAACC,KAAMtD,OAAOC,SAASC,kBAE5BqD,KALH,sBAKQ,4BAAA9F,EAAA,sEACoBkE,EAAOY,QAAQG,eAAeD,OADlD,cACE9C,EADF,OAEJoC,EAAapC,GAFT,SAGEgD,IAHF,4CAIHa,OAAM,SAAAC,GAGPzD,OAAO0D,MAAM,sEAbK,2CAAH,sDAuBrB,OAJA1D,OAAO0D,MAAQ,SAAC9C,GAA6B,IAApBpB,EAAmB,uDAAd,UAC5BwB,EAAI2C,KAAK,QAAU,CAAC/C,UAASpB,UAIb,qBAAThC,GACgB,qBAAbiE,GACW,qBAAXE,GACc,IAArBtD,EAAU8E,QACQ,qBAAX7E,EAEH,6CAKP,gDAEE,cAAC,EAAD,CAAQD,UAAWA,EAAWC,OAAQA,IACtC,cAAC,EAAD,CAAaG,eAxDM,SAAAG,GACrB+C,EAAOY,QACJ9D,eAAeG,EAASyB,OAAQzB,EAAS0B,IAKzC+C,KAAK,CAACC,KAAMtD,OAAOC,SAASC,kBAC5BqD,KAPH,sBAOQ,4BAAA9F,EAAA,sEACoBkE,EAAOY,QAAQG,eAAeD,OADlD,cACE9C,EADF,OAEJoC,EAAapC,GAFT,SAGEgD,IAHF,4CAIHa,OAAM,SAAAC,GAEPzD,OAAO0D,MAAM,kEA2Cf,cAAC,EAAD,CAAc/D,UAAWA,EAAWC,gBAAiBA,EAAiBC,UAAWA,IACjF,cAAC,EAAD,QC7IN+D,IAASC,OACP,cAAC,IAAMC,WAAP,UACE,cAAC,EAAD,MAEF3C,SAAS4C,eAAe,W","file":"static/js/main.f274d923.chunk.js","sourcesContent":["import Web3 from 'web3';\nimport Wallet from './contracts/Wallet.json';\nimport detectEthereumProvider from '@metamask/detect-provider';\n// Added this line below because the new way of connecting metamask was suuuuper slow.\n// This helped slightly speed it up but not by much. bandaid solution.\n// require('events').EventEmitter.prototype._maxListeners = 100;\n\n// This is ok for development. But now that we are going to send this to production, we will modify this function\n// const getWeb3 = () => {\n//     // now with our Web3 object, we have a connection to the ETH blockchain. wild.\n//     return new Web3('http://127.0.0.1:9545/')\n// }\n\n// Old way with deprecated functions\nconst getWeb3 = () => {\n    return new Promise((resolve, reject) => {\n        // This guarantees that all the JS and browser extensions have been loaded before beginning to execute code below\n        window.addEventListener('load', async () => {\n            // Test if Metamask is injected in our JS code.\n            // When MetaMask is present, it will inject an ethereum object onto the window object\n            if(window.ethereum) {\n                // Web3 provider object\n                const web3 = new Web3(window.ethereum);\n                // Asks user if they'd like to grant dapp access to MetaMask\n                try{\n                    await window.ethereum.enable(); \n                    resolve(web3);\n                } catch(error) {\n                    // Catch in case user refuses to enable MetaMask\n                    reject(error);\n                }\n            // This is in case user is utilizing an old version of MetaMask\n            } else if(window.web3) {\n                resolve(window.web3);\n            // In the case that user doesn't have MetaMask installed at all\n            } else {\n                reject('Must install MetaMask to use dapp');\n            }\n\n        })\n    })\n}\n\n// This is the new way to connect MetaMask to site but it makes the website VERY slow. need to fix.\n// const getWeb3 = () => {\n//     return new Promise(async (resolve, reject) => {\n//         let provider = await detectEthereumProvider();\n//         if(provider) {\n//             await provider.request({method: 'eth_requestAccounts'});\n//             try {\n//                 const web3 = new Web3(window.ethereum);\n//                 resolve(web3);\n//             } catch(err) {\n//                 reject(err);\n//             }\n//         }\n//         reject('Please install Metamask to use this application');\n//     });\n// }\n\n\n\n\n\n// Next step is to build a contract instance \n// // object produced by web3, allows you to directly interact with smartContract\n// This function creates a contract instance\nconst getWallet = async web3 => {\n    // Extract network ID from contract abstraction (ABI??)\n    const networkId = await web3.eth.net.getId();\n    // With this networkID, we'll be able to extract the information we'll need from Contract Artifact\n    // This variable will store all data of our smartContract deployment\n    const contractDeployment = Wallet.networks[networkId];\n    // return contract instance using web3\n    return new web3.eth.Contract(\n        // pass ABI of smartcontract\n        // ABI is a JSON object which defines function signature of our smartContract \n        Wallet.abi,\n        // address of smartContract\n        contractDeployment && contractDeployment.address\n    );\n};\n\n// Our local development blockchain accepts transactions that aren't signed. This will not be the case \n// // once we send our dapp to production on Mainnet. Hence we need to setup the MetaMask integration in order to sign\n// // each transaction we make.\n\nexport { getWeb3, getWallet }\n\n// When you come back to review this, try to see if you can get this to work \n// by completely separating client and blockchain builds from each other. ","import React from 'react';\n\nfunction Header({approvers, quorum}) {\n    return (\n        <header>\n            <ul>\n                <li> Approvers: {approvers.join(', ')}</li>\n                <li> Quorum: {quorum}</li> \n            </ul>\n\n        </header>\n    )\n}\n\nexport default Header;","// This file is what allows us to modify the smartContract data using web3\n\nimport React, {useState} from 'react';\n\n// createTransfer param will come from App.js\nfunction NewTransfer({createTransfer}) {\n    const [transfer, setTransfer] = useState(undefined);\n\n    const submit = e => {\n        e.preventDefault();\n        createTransfer(transfer);\n    }\n\n    const updateTransfer = (e, field) => {\n        const value = e.target.value;\n        // ... destructures the Transfer struct\n        setTransfer({...transfer, [field]: value});\n    }\n\n    return(\n        <div>\n            <h2>Create Transfer</h2>\n            <form onSubmit={(e) => submit(e)}>\n                <label htmlFor=\"amount\">Amount</label>\n                <input\n                    id=\"amount\"\n                    type=\"text\"\n                    onChange={e => updateTransfer(e, 'amount')}\n                    />\n                <label htmlFor=\"to\">To</label>\n                <input\n                    id=\"to\"\n                    type=\"text\"\n                    onChange={e => updateTransfer(e, 'to')}\n                    />\n                <button>Submit</button>\n            </form>\n        </div>\n    )\n}\n\nexport default NewTransfer;","import React from 'react';\n\n\nfunction TransferList({transfers, approveTransfer, approvals}) {    \n    return (\n        <div>\n            <h2>Transfers</h2>\n            <table>\n                <thead>\n                    <tr>\n                        <th>Id</th>\n                        <th>Amount</th>\n                        <th>Address</th>\n                        <th>Approvals</th>\n                        <th>Sent</th>\n                    </tr>\n                </thead>\n                <tbody>\n                    {transfers.map(transfer => {\n                        let button;\n                        if(approvals[window.ethereum.selectedAddress]){\n                            if(approvals[window.ethereum.selectedAddress][transfer.id]){\n                                button = <button disabled >Approve</button>\n                            } else {\n                                button = <button onClick={() => approveTransfer(transfer.id)}>Approve</button>\n                            }\n                        } else {\n                            button = <button onClick={() => approveTransfer(transfer.id)}>Approve</button>\n                        }\n\n                        return(\n                            <tr key={transfer.id}>\n                                <td>{transfer.id}</td>\n                                <td>{transfer.amount}</td>\n                                <td>{transfer.to}</td>\n                                <td>\n                                    {transfer.approvals}\n                                    { button }\n                                </td>\n                                <td>{transfer.sent ? 'yes' : 'no'}</td>\n                            </tr>\n                        )\n                    })}\n                </tbody>\n            </table>\n        </div>\n\n    )\n}\n\nexport default TransferList;\n\n","import EventEmitter from 'events';\n\nexport default new EventEmitter();","import React, { useEffect, useState } from 'react';\nimport Bus from '../utils/Bus';\n\nimport './index.css';\n\nexport const Flash = () => {\n    let [visibility, setVisibility] = useState(false);\n    let [message, setMessage] = useState('');\n    let [type, setType] = useState('');\n\n    useEffect(() => {\n        Bus.addListener('flash', ({message, type}) => {\n            setVisibility(true);\n            setMessage(message);\n            setType(type);\n            setTimeout(() => {\n                setVisibility(false);\n            }, 4000);\n        });\n                \n\n    }, []);\n\n    useEffect(() => {\n        if(document.querySelector('.close') !== null) {\n            document\n            .querySelector('.close')\n            .addEventListener('click', () => setVisibility(false));\n        }\n    })\n\n    return (\n        visibility && <div className={`alert alert-${type}`}>\n                <span className=\"close\"><strong>X</strong></span>\n                <p>{message}</p>\n            </div>\n    )\n}\n","// Need to learn about React Hooks API (useEffect + useState)\nimport React, {useEffect, useState} from 'react';\n\nimport { getWeb3, getWallet } from './utils.js';\nimport Header from './Header.js';\nimport NewTransfer from './NewTransfer.js';\nimport TransferList from './TransferList.js';\nimport {Flash} from './flash/index.js';\nimport Bus from './utils/Bus.js';\n\nfunction App() {\n  // Define state in this component\n  const [web3, setWeb3] = useState(undefined);\n  const [accounts, setAccounts] = useState(undefined);\n  const [wallet, setWallet] = useState(undefined);\n  const [approvers, setApprovers] = useState([]);\n  const [quorum, setQuorum] = useState(undefined);\n  const [transfers, setTransfers] = useState([]);\n  const [approvals, setApprovals] = useState({});\n\n  // Equivalent of ComponentDidMount\n  useEffect(() => {\n    const init = async () => {\n      // We added the 'await' after setting up the MetaMask stuff in utils.js\n      const web3 = await getWeb3();\n      // gets list of accounts generated by ganache\n      const accounts = await web3.eth.getAccounts();\n      // gets contract instance wallet\n      const wallet = await getWallet(web3);\n      const approvers = await wallet.methods.getApprovers().call();\n      const quorum = await wallet.methods.quorum().call();\n      const transfers = await wallet.methods.getTransfers().call();\n      \n      // Following lines set the state variables\n      setWeb3(web3);\n      setAccounts(accounts);\n      setWallet(wallet);\n      setApprovers(approvers);\n      setQuorum(quorum);\n      setTransfers(transfers);\n      // WHY CAN'T I GET THIS TO WOORK!!! LOL\n      // IF I COPY AND PASTE THE CODE OF FUNCTION INTO HERE, IT'LL WORK JUST FINE\n      // BUT NOT WHEN I CALL THE FUNCTION ITSELF. HMMMMM\n\n      // I got it to work :cool:\n      // Still not sure if this is a correct implementation buy hey!\n      setApprovals(await determineApprovals(transfers, wallet));\n      // await determineApprovals();\n      };\n    init();\n  })\n\n  // Would like to run this function as soon as someone changes which account they're using on MetaMask. \n  // I'd imagine i gotta add an eventListener somewhere\n  const determineApprovals = async (transferList, _wallet) => {\n    let transferonies;\n    let tempWallet;\n\n    if(transferList){\n      transferonies = transferList;\n    } else {\n      transferonies = transfers;\n    }\n\n    if(_wallet){\n      tempWallet = _wallet;\n    } else {\n      tempWallet = wallet;\n    }\n\n    let approvalObj = {\n      [window.ethereum.selectedAddress]: {}\n    };\n    for(let i=0; i < transferonies.length; i++){\n      if(await tempWallet.methods.approvals(window.ethereum.selectedAddress, transferonies[i].id).call()){\n        approvalObj[window.ethereum.selectedAddress][transferonies[i].id] = true;\n      } else {\n        approvalObj[window.ethereum.selectedAddress][transferonies[i].id] = false;\n      }\n    }\n    if(transferList){\n      return approvalObj;\n    } else {\n      setApprovals(approvalObj);\n    }\n  }\n\n  const createTransfer = transfer => {\n    wallet.methods\n      .createTransfer(transfer.amount, transfer.to)\n      // not going to call() because that's only when you want to read data from blockchain\n      // .call()\n      // when you want to modify data or send a transaction, we use send()\n      // .send({from: accounts[0]})\n      .send({from: window.ethereum.selectedAddress})\n      .then(async () => {\n        const transfers = await wallet.methods.getTransfers().call();\n        setTransfers(transfers);  \n        await determineApprovals(); \n      }).catch(err => {\n        // Ideally the app shouldn't even prompt the user to confirm createTransfer with their MetaMask\n        window.flash(\"Only approved addresses are allowed to create a transfer\");\n      });\n  }\n\n  const approveTransfer = async transferId => {\n    wallet.methods\n      .approveTransfer(transferId)\n      // Remember we are modifying data, not reading it. hence send();\n      .send({from: window.ethereum.selectedAddress})\n      // .send({from: accounts[0]})\n      .then(async () => {\n        const transfers = await wallet.methods.getTransfers().call();\n        setTransfers(transfers);  \n        await determineApprovals();\n      }).catch(err => {\n        // console.log('ERROR');\n        // console.log(err);\n        window.flash(\"There was an error in processing your request. Please try again\");\n      });\n      // console.log(await wallet.methods.approvals(window.ethereum.selectedAddress, transferId).call());\n  }\n\n  // For flashing error messages\n  window.flash = (message, type=\"success\") => {\n    Bus.emit('flash', ({message, type}))\n  }\n\n  if(\n    typeof web3 === 'undefined'\n    || typeof accounts === 'undefined'\n    || typeof wallet === 'undefined'\n    || approvers.length === 0\n    || typeof quorum === 'undefined'\n  ) {\n    return <div>Loading...</div>\n  }\n\n  \n  return (\n    <div>\n      MultiSig Dapp\n      <Header approvers={approvers} quorum={quorum} />\n      <NewTransfer createTransfer={createTransfer} />\n      <TransferList transfers={transfers} approveTransfer={approveTransfer} approvals={approvals} />\n      <Flash />\n    </div>\n\n  );\n}\n\nexport default App;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport App from './App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n// reportWebVitals();\n"],"sourceRoot":""}